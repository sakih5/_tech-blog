---
title: メール配信をGASで自動化してみる
publishedDate: 2025-10-02
---

# 自動化すること

Google Apps Script（GAS）を使って以下の作業を自動化する

1. 表データの加工（各表の結合）
2. メール本文作成・下書き保存

※下書きに作成されたものを送信するのは人手でやる（ミスを防ぐため）

# 自動化にあたって気を付けること

- **フォルダ構成を崩さない**こと（フォルダ名やファイルの置き場所を変えると、PC が認識できずエラーになる）
- **ファイル名・列名を必ずスクリプトに書いた内容に揃える**こと（でないとファイル・列を PC が認識できずエラーになる）
- メール作成の際にネックになるのが、差出人を Google アカウントの Gmail アドレス以外に設定したい場合。

  → 会社のメールソフトが Gmail であれば何も問題はないが、他のメールソフトを使用している場合、**GAS 以外の自動化方法も検討すること**

# フォルダ構成

```txt
マイドライブ
└── 請求書メール自動化  # プロジェクトフォルダを作成、その中に作業で必要なファイルを集約
    ├── Input  # 生データを格納
    │   ├── Users.csv
    │   ├── Types.csv
    │   └── CreditCardLinks.csv
    ├── Output # 加工データを格納
    │   ├── Old # 加工データのバックアップを格納
    │   │   └── Data_YYYYMMDDHHMMSS.csv
    │   └── Data.csv
    ├── Templates # メール本文のテンプレートを格納
    │   ├── Template_CreditCard.txt
    │   └── Template_BankTransfer.txt
    └── Scripts # 自動化のスクリプトを格納
        └── MailCreate.gs  # Google Apps Scriptのスクリプト
```

# 各ファイルの詳細

## `Input/Users.csv`

|  id | name     | email                    | type          |
| --: | :------- | :----------------------- | :------------ |
|   1 | 山田花子 | sakihamamura5@gmail.com  | credit-card   |
|   2 | 加藤茂樹 | mochimochi5259@gmail.com | credit-card   |
|   3 | 佐藤太郎 | sakihamamura5@gmail.com  | bank-transfer |

## `Input/Types.csv`

| type          | due         |
| ------------- | ----------- |
| credit-card   | 10 月 10 日 |
| bank-transfer | 10 月 15 日 |

## `Input/CreditCardLinks.csv`

| link                  |
| --------------------- |
| https://example.com/1 |
| https://example.com/2 |

## `Output/Data.csv`（スクリプトから自動生成されるファイル）

|  id | name     | email                    | type          | due         | link                  |
| --: | :------- | :----------------------- | :------------ | :---------- | :-------------------- |
|   1 | 山田花子 | sakihamamura5@gmail.com  | credit-card   | 10 月 10 日 | https://example.com/1 |
|   2 | 加藤茂樹 | mochimochi5259@gmail.com | credit-card   | 10 月 10 日 | https://example.com/2 |
|   3 | 佐藤太郎 | sakihamamura5@gmail.com  | bank-transfer | 10 月 15 日 | nan                   |

## `Templates/Template_CreditCard.txt`

```txt
{name} 様

お世話になっております。○○でございます。

今月のお支払い方法についてご案内いたします。

お支払い方法: クレジットカード払い
お支払い期日: {due}

以下のリンクより決済をお願いします。

{link}

お支払いのほどよろしくお願いいたします。

○○
```

## `Templates/Template_BankTransfer.txt`

```txt
{name} 様

お世話になっております。○○でございます。

今月のお支払い方法についてご案内いたします。

お支払い方法: 口座振込
お支払い期日: {due}

以下の口座にお振込みをお願いいたします。

銀行名: ○○
口座番号: ○○

お支払いのほどよろしくお願いいたします。

○○
```

## `Scripts/MailCreate.gs`

処理の大まかな流れは以下

1. 表データの加工（各表の結合）

   1. `Input/Users.csv`と`Input/Types.csv`を**結合**する。**結合キー**は`type`
   2. `Input/Users.csv`と`Input/Types.csv`を**結合**する。`Input/Users.csv`の`type`列が`credit-card`という値となる行にだけ、`Input/CreditCardLinks.csv`の`links`行の値を追記していく
   3. できた大きなテーブルを`Output/Data.csv`として出力する

2. メール本文作成・下書き保存

   1. `Output/Data.csv`を読み込み、**1 行ずつ処理**していく
   2. 値を取り出し、`type`列の値が`credit-card`であれば`Templates/Template_CreditCard.txt`を、`bank-transfer`であれば`Templates/Template_BankTransfer.txt`を読み込む（**テンプレートの読み込み**）
   3. それぞれの**テンプレートに値を埋め込み**、**メール本文に貼り付ける**
   4. 差出人を`saki@ee.em-net.ne.jp`にする
   5. 宛先を`email`に記載されている値にする
   6. メールを**下書きに保存**する

```js
/** =========================================================
 * 請求書メール作成自動化
 * - DriveのルートはフォルダID直指定（迷子ゼロ）
 * - CSVは CP932(Shift_JIS) で入出力を統一（文字化け防止）
 * - Output/Data.csv を生成し、既存は Output/Old/Data_YYYYMMDDHHMMSS.csv へ退避
 * - Data.csv を基に Gmail 下書きを作成
 * ========================================================= */

/* ========= 設定（必ず置き換え） ========= */
const ROOT_FOLDER_ID = ''; // https://drive.google.com/drive/folders/ の末尾IDを貼る
const FROM_ADDRESS = ''; // Gmailの「他のメールアドレスを追加」で登録済みの差出人

/* ========= 固定値（名前を明快に統一） ========= */
const ENCODING = 'Shift_JIS'; // = CP932
const FOLDER_INPUT = 'Input';
const FOLDER_OUTPUT = 'Output';
const FOLDER_ARCHIVE = 'Old';
const FOLDER_TEMPLATES = 'Templates';

const FILE_DATA = 'Data.csv';
const FILE_USERS = 'Users.csv';
const FILE_TYPES = 'Types.csv';
const FILE_CC_LINKS = 'CreditCardLinks.csv';
const FILE_TPL_CC = 'Template_CreditCard.txt';
const FILE_TPL_BANK = 'Template_BankTransfer.txt';

/* ========= エントリーポイント ========= */
/** ワンボタン実行：データセット作成 → 下書き作成 */
function main() {
  buildMailDataset(); // Output/Data.csv を作る（既存は Old へ退避）
  //   createDraftMails();   // Data.csv + テンプレから Gmail 下書き作成（差出人はプライマリ）
  createDraftsViaGmailAPI();
}

/* ========= ステップ1：Data.csv を構築 ========= */
/**
 * Input の Users/Types/Links を突合し、Output/Data.csv を再構成する
 * - 既存の Data.csv は Old へ退避（タイムスタンプを付与）
 */
function buildMailDataset() {
  const rootFolder = DriveApp.getFolderById(ROOT_FOLDER_ID);
  const inputFolder = getRequiredSubfolder(rootFolder, FOLDER_INPUT);
  const outputFolder = getOrCreateSubfolder(rootFolder, FOLDER_OUTPUT);

  // 読み込み（CSV: CP932、スプレッドシート: displayValues）
  const usersTable = readTableCP932(inputFolder, FILE_USERS); // 期待: id,name,email,type
  const typesTable = readTableCP932(inputFolder, FILE_TYPES); // 期待: type,due
  const linksTable = readTableCP932(inputFolder, FILE_CC_LINKS); // 期待: link（1列目）

  assertHasBody(usersTable, FILE_USERS);
  assertHasBody(typesTable, FILE_TYPES);

  const usersHeaderMap = parseHeader(usersTable[0]); // {id,name,email,type}
  const typesHeaderMap = parseHeader(typesTable[0]); // {type,due}

  assertHeader(usersHeaderMap, ['id', 'name', 'email', 'type'], FILE_USERS);
  assertHeader(typesHeaderMap, ['type', 'due'], FILE_TYPES);

  // type → due のマップを構築
  /** @type {Record<string,string>} */
  const typeToDueMap = {};
  for (let i = 1; i < typesTable.length; i++) {
    const row = typesTable[i];
    typeToDueMap[safe(row, typesHeaderMap.type)] = safe(
      row,
      typesHeaderMap.due
    );
  }

  // 出力行（ヘッダ + 本文）
  const outputRows = [['id', 'name', 'email', 'type', 'due', 'link']];

  // クレカ用リンクをラウンドロビンで消費（linksTable[0] はヘッダ）
  let linkRowIndex = 1;
  const linkDataCount = Math.max(linksTable.length - 1, 0);

  for (let i = 1; i < usersTable.length; i++) {
    const row = usersTable[i];
    const id = safe(row, usersHeaderMap.id);
    const name = safe(row, usersHeaderMap.name);
    const email = safe(row, usersHeaderMap.email);
    const type = safe(row, usersHeaderMap.type);
    const due = typeToDueMap[type] || '';

    let linkValue = '';
    if (type === 'credit-card' && linkDataCount > 0) {
      linkValue = safe(linksTable[linkRowIndex], 0); // 先頭列が link
      linkRowIndex++;
      if (linkRowIndex >= linksTable.length) linkRowIndex = 1; // 枯れたら先頭へ
    }
    outputRows.push([id, name, email, type, due, linkValue]);
  }

  // 既存 Data.csv を Old へ退避
  archiveIfExists(outputFolder, FILE_DATA);

  // 出力（CP932/Shift_JIS 明示）
  const csvText = outputRows.map((r) => r.map(csvEscape).join(',')).join('\n');
  const csvBlob = Utilities.newBlob(
    '',
    'text/csv',
    FILE_DATA
  ).setDataFromString(csvText, ENCODING);
  outputFolder.createFile(csvBlob);
}

/* ========= ステップ2：下書きメール作成 ========= */
/**
 * Data.csv + テンプレから「下書き」を作成（Gmail API）
 * 件名：YYYY年MM月分のご請求について（実行日の年月）
 * 前提：高度なGoogleサービス「Gmail API」をON
 */
function createDraftsViaGmailAPI() {
  const rootFolder = DriveApp.getFolderById(ROOT_FOLDER_ID);
  const outputFolder = getRequiredSubfolder(rootFolder, FOLDER_OUTPUT);
  const tplFolder = getRequiredSubfolder(rootFolder, FOLDER_TEMPLATES);

  // 差出人エイリアスの存在確認（送信時整合のため）
  ensureAliasOrThrow(FROM_ADDRESS);

  // Data.csv（CP932）読込
  const dataFileIter = outputFolder.getFilesByName(FILE_DATA);
  if (!dataFileIter.hasNext())
    throw new Error(`${FOLDER_OUTPUT}/${FILE_DATA} が見つかりません`);
  const rows = Utilities.parseCsv(
    dataFileIter.next().getBlob().getDataAsString(ENCODING)
  );
  if (rows.length < 2) throw new Error('Data.csv にデータ行がありません');

  const headerMap = parseHeader(rows[0]); // id,name,email,type,due,link…

  // テンプレ
  const tplCredit = readText(tplFolder, FILE_TPL_CC);
  const tplBank = readText(tplFolder, FILE_TPL_BANK);

  // 件名（スクリプトTZでゼロ埋め）
  const tz = Session.getScriptTimeZone();
  const now = new Date();
  const yyyy = Utilities.formatDate(now, tz, 'yyyy');
  const mm = Utilities.formatDate(now, tz, 'MM');
  const subject = `${yyyy}年${mm}月分のご請求について`;

  // 下書き作成（From ヘッダをエイリアスに）
  let draftCount = 0;
  for (let i = 1; i < rows.length; i++) {
    const row = rows[i];
    const to = safe(row, headerMap.email);
    const name = safe(row, headerMap.name);
    const type = safe(row, headerMap.type);
    const due = safe(row, headerMap.due);
    const link = 'link' in headerMap ? safe(row, headerMap.link) : '';
    if (!to) continue;

    const body =
      type === 'credit-card'
        ? tplCredit
            .replace('{name}', name)
            .replace('{due}', due)
            .replace('{link}', link)
        : type === 'bank-transfer'
        ? tplBank.replace('{name}', name).replace('{due}', due)
        : null;
    if (!body) continue;

    // プレーンテキストMIMEを組み立て → Base64URL → Drafts.create
    const mime = buildMimeMessage({ from: FROM_ADDRESS, to, subject, body });
    const raw = toBase64Url(mime);
    Gmail.Users.Drafts.create({ message: { raw } }, 'me');
    draftCount++;
  }

  Logger.log(`[DRAFT] 作成完了: ${draftCount} 通`);
}

/* ========= 汎用ヘルパー ========= */

/**
 * 必須のサブフォルダを取得（なければエラー）
 * @param {GoogleAppsScript.Drive.Folder} parent
 * @param {string} name
 * @returns {GoogleAppsScript.Drive.Folder}
 */
function getRequiredSubfolder(parent, name) {
  const it = parent.getFoldersByName(name);
  if (!it.hasNext())
    throw new Error(
      `サブフォルダ「${name}」が見つかりません（親: ${parent.getName()}）`
    );
  return it.next();
}

/**
 * サブフォルダ取得（なければ作成）
 * @param {GoogleAppsScript.Drive.Folder} parent
 * @param {string} name
 */
function getOrCreateSubfolder(parent, name) {
  const it = parent.getFoldersByName(name);
  return it.hasNext() ? it.next() : parent.createFolder(name);
}

/**
 * 既存ファイル filename を Old に Data_YYYYMMDDHHMMSS.csv として退避
 * @param {GoogleAppsScript.Drive.Folder} outputFolder
 * @param {string} filename
 */
function archiveIfExists(outputFolder, filename) {
  const it = outputFolder.getFilesByName(filename);
  if (!it.hasNext()) return;

  const archiveFolder = getOrCreateSubfolder(outputFolder, FOLDER_ARCHIVE);
  const ts = Utilities.formatDate(
    new Date(),
    Session.getScriptTimeZone(),
    'yyyyMMddHHmmss'
  );

  while (it.hasNext()) {
    const file = it.next();
    file.setName(`Data_${ts}.csv`);
    file.moveTo(archiveFolder);
  }
}

/**
 * テーブル読み込み：CSVはCP932、GoogleシートはdisplayValues
 * @param {GoogleAppsScript.Drive.Folder} folder
 * @param {string} name
 * @returns {string[][]}
 */
function readTableCP932(folder, name) {
  const it = folder.getFilesByName(name);
  if (!it.hasNext())
    throw new Error(
      `${name} が見つかりません（フォルダ: ${folder.getName()}）`
    );
  const file = it.next();
  const mime = file.getMimeType();

  if (mime === MimeType.GOOGLE_SHEETS || /spreadsheet/i.test(mime)) {
    const ss = SpreadsheetApp.openById(file.getId());
    const sh = ss.getSheets()[0];
    return sh.getDataRange().getDisplayValues();
  } else {
    const text = file.getBlob().getDataAsString(ENCODING); // CP932
    return Utilities.parseCsv(text);
  }
}

/**
 * ヘッダー配列 → { colName: index } に変換（trim済み）
 * @param {string[]} headerRow
 */
function parseHeader(headerRow) {
  const map = {};
  headerRow.forEach((h, i) => {
    map[String(h).trim()] = i;
  });
  return map;
}

/**
 * 必須ヘッダー検証（不足があればエラー）
 * @param {Record<string, number>} headerMap
 * @param {string[]} requiredKeys
 * @param {string} sourceName
 */
function assertHeader(headerMap, requiredKeys, sourceName) {
  const missing = requiredKeys.filter((k) => !(k in headerMap));
  if (missing.length) {
    throw new Error(`${sourceName} のヘッダーに不足: ${missing.join(', ')}`);
  }
}

/**
 * データ行存在検証（ヘッダーのみ/空はNG）
 * @param {string[][]} rows
 * @param {string} sourceName
 */
function assertHasBody(rows, sourceName) {
  if (!rows || rows.length < 2) {
    throw new Error(`${sourceName} にデータ行がありません（ヘッダーのみ/空）`);
  }
}

/**
 * 安全セル参照（欠損なら空文字）
 * @param {string[]} row
 * @param {number} idx
 */
function safe(row, idx) {
  if (!row || idx == null || idx >= row.length) return '';
  return String(row[idx]);
}

/**
 * CSVエスケープ（, " 改行を囲む）
 * @param {any} v
 */
function csvEscape(v) {
  const s = v == null ? '' : String(v);
  return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
}

/**
 * テンプレートファイル読み込み（UTF-8文字列）
 * @param {GoogleAppsScript.Drive.Folder} folder
 * @param {string} name
 */
function readText(folder, name) {
  const it = folder.getFilesByName(name);
  if (!it.hasNext())
    throw new Error(
      `${name} が見つかりません（フォルダ: ${folder.getName()}）`
    );
  return it.next().getBlob().getDataAsString('UTF-8');
}

/* ========= 差出人エイリアス検証 & MIMEユーティリティ ========= */

/**
 * 差出人エイリアスがGmailに登録済みか検証する。
 * - 高度なサービス(Gmail API)が有効なら SendAs を参照
 * - 未有効/権限なしなら GmailApp.getAliases() にフォールバック
 * 該当がなければ Error を投げる
 * @param {string} address 検証したい差出人メールアドレス
 */
function ensureAliasOrThrow(address) {
  if (!address) throw new Error('FROM_ADDRESS が未設定です。');

  // 1) 高度なサービス: Gmail.Users.Settings.SendAs
  try {
    const res = Gmail.Users.Settings.SendAs.list('me');
    const list = (res && res.sendAs) || [];
    const ok = list.some(
      (sa) =>
        sa.sendAsEmail === address &&
        (sa.isPrimary ||
          sa.isDefault ||
          sa.verificationStatus === 'accepted' ||
          sa.isEnabled)
    );
    if (ok) return;

    // 2) フォールバック: GmailApp.getAliases()
    const aliases = GmailApp.getAliases(); // 文字列配列
    const primary = Session.getActiveUser().getEmail();
    const ok2 = aliases.includes(address) || address === primary;
    if (!ok2) {
      throw new Error(buildAliasErrorMessage(address, list, aliases, primary));
    }
    return;
  } catch (e) {
    // 高度なサービスが未有効などで上の try が落ちた場合は、GmailApp だけでチェック
    const aliases = GmailApp.getAliases();
    const primary = Session.getActiveUser().getEmail();
    const ok = aliases.includes(address) || address === primary;
    if (!ok) {
      throw new Error(buildAliasErrorMessage(address, [], aliases, primary));
    }
  }
}

/** エイリアス検証のエラーメッセージ整形 */
function buildAliasErrorMessage(address, sendAsList, aliases, primary) {
  const sendAsStr =
    sendAsList && sendAsList.length
      ? sendAsList
          .map((sa) => `${sa.sendAsEmail}${sa.isDefault ? ' (default)' : ''}`)
          .join(', ')
      : '(SendAs 取得不可/未有効)';
  const aliasStr =
    aliases && aliases.length ? aliases.join(', ') : '(エイリアスなし)';
  return [
    `差出人エイリアス '${address}' がGmailに登録されていません。`,
    `- プライマリ: ${primary}`,
    `- SendAs: ${sendAsStr}`,
    `- GmailApp.getAliases(): ${aliasStr}`,
    `Gmail設定 > アカウント > 「他のメールアドレスを追加」で '${address}' を登録・確認済みにしてください。`,
    `※ Apps Script の「高度なGoogleサービス」で Gmail API をONにすると SendAs を厳密に検証できます。`,
  ].join('\n');
}

/**
 * シンプルなプレーンテキストMIMEを組み立てる
 * @param {{from:string,to:string,subject:string,body:string}} p
 */
function buildMimeMessage(p) {
  const lines = [
    `From: ${p.from}`,
    `To: ${p.to}`,
    `Subject: ${encodeToMimeHeader(p.subject)}`,
    'MIME-Version: 1.0',
    'Content-Type: text/plain; charset=UTF-8',
    '',
    p.body || '',
  ];
  return lines.join('\r\n');
}

/** RFC 2047 風の簡易エンコード（日本語件名用）*/
function encodeToMimeHeader(str) {
  // Base64で =?UTF-8?B?...?= 形式に
  const b64Std = Utilities.base64EncodeWebSafe(
    Utilities.newBlob(str, 'text/plain', '').getBytes()
  )
    .replace(/-/g, '+')
    .replace(/_/g, '/'); // WebSafe→標準
  return `=?UTF-8?B?${b64Std}?=`;
}

/** Base64URL へ変換（Gmail API raw 用）*/
function toBase64Url(str) {
  const b64 = Utilities.base64Encode(str);
  return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
}
```

# 動作確認

1. （初回のみ）サービスに Gmail API を追加する
2. 実行したい関数として`main`を選択して実行ボタンを押す
3. 実行ログが現れて、処理が始まる
4. 実行完了の表示が出てきたら、Gmail を開いて下書きにメールが作成されているか確認する

# 感想

- 普段使っているメールソフトが Outlook なのであれば、**VBA で自動化した方が差出人の設定に手間取らなくて良い**のではと感じた。
- メールソフト依存を気にするのであれば、Python を使った方が良いと感じた。しかし、GAS や VBA を使うことによって、**環境構築なしに自動化スクリプトが作れる**のであれば、その方が気楽ではある。
- どのメールは作成済みで、どのメールは作成できなかったかを、CSV で出力しても良いのかなと思った。
