---
title: 読書メモ「達人に学ぶDB設計徹底指南書 第2版」
publishedDate: 2025-11-21
status: 作成中
---

データベース設計の3要素

1. 論理設計: 正規化やER図を使ったデータのモデル設計

    - 外部スキーマ
    - 概念スキーマ
    - 内部スキーマ

2. 物理設計: サーバやストレージといった物理的なハードウェアレベルの設計
3. 実装設計: 特定のデータベース製品を前提に、具体的な構築の手順や方法

※ 論理設計と物理設計はトレードオフの関係にある

データと情報の違い

- データ: ある形式（フォーマット）に揃えられた事実のこと
- 情報: データと文脈を合成して生まれる

---

データベースとDBMSの違い

- データベース: データの集積を指す論理的概念
- DBMS（Database Management System）: データベースを実装したソフトウェア。データベースを管理するためのシステム

---

データベース設計を制する者はシステム開発を制す
← システムがデータのフォーマットに合わせて作られるため（システムに合わせてデータを作るのではない ← ？）

---

エンティティは設計の中心概念であり、実装の際に

- DB側だとテーブル（表）
- アプリコード側だとエンティティクラス（モデル、ORMクラス）

へと姿を変える。

---

アトリビュート（属性）: そのエンティティが持つ情報（列）のこと
キー: 属性の中でも特別な役割を持つ「列」のこと

※全ての列がキーというわけではない
※まず知っておくべきキーは以下の4つ

1. 主キー: レコードを一意に特定するキー
2. 外部キー: 外部テーブルとの「紐づけ」に使われるキー
3. ユニークキー: 1つとして同じ値のレコードが無いキー
4. 複合キー: 複数列の組み合わせが一意になるキー

---

スーパーキー: ある行を一意に特定できる列の組み合わせの全部（余計な列を含んでいてもOK）
 └─ 候補キー: スーパーキーのうち、最小限の列で成り立っているもの、つまりこれ以上削ると一意にならない、一番シンプルなキー（候補キーは複数種あることもある）
     └─ 主キー: 候補キーの中から1つの組み合わせを取り出して主キーとする

---

外部キーについて

- 外部キーには**参照整合性制約**が課される
  - 参照整合性制約があると、親テーブルに無い値を子テーブルの外部キーに追加できなくなる
  - 親テーブルの値を削除しようとした際の挙動は**カスケード**で指定できる
  - 表記ゆれに伴うエラーを防ぐため、キーとなる列には、コードやIDなど表記体系の定まった固定長文字列を用いる。

---

様々な制約

- NOT NULL制約
- 一意制約
- CHECK制約

---

正規化をする理由

- 値の表記ゆれを防ぎ、集計の効率を上げる（データの整合性が上がる）

正規化のデメリット

- 正規化しすぎると、パフォーマンスが落ちる

---

物理設計の流れ

1. テーブル定義
2. インデックス定義
3. ハードウェアのサイジング
4. ストレージの冗長構成決定
5. ファイルの物理配置決定

---

ハードウェアのサイジングの実際

- **キャパシティ**と**パフォーマンス**の2つの観点から行う
- テーブル定義とインデックス定義が終わってからでないと、システムで利用するデータ量は概算できない

感想:
PoCフェーズでハードウェアのサイジングを決める意味は薄いのかもしれない
とりあえずストレージは1000GBでいいのかもしれない
ストレージは穴ぼこが空いて使えないところがだんだん増えてくるから（寿命だから）

---

DBMSは以下ファイルで構成される。

※論理的に分離しても、物理的に分離しなければI/Oが分散されないことに注意。

- データファイル
- インデックスファイル
- システムファイル
- 一時ファイル
- ログファイル

---

- オンラインバックアップ: DBを停止せずにバックアップを取得すること
- オフラインバックアップ: DBを完全に停止してからデータファイルを丸ごとコピーする方法

---

- リストア: フルバックアップのファイルをデータベースに戻す
- リカバリ: 差分（または増分）バックアップしていたトランザクションログを適用する
- ロールフォワード: データベースサーバーに残っているトランザクションログを適用する

---

論理設計

「テーブルに重複行は存在できない」
