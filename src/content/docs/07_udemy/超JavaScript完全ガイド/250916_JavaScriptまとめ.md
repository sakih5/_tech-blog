---
title: JavaScriptまとめ
---

### JavaScript とは？

- 定義: JavaScript はコンパイル不要で**JavaScript エンジン**が直接実行するプログラミング言語

- 他言語との比較

  - 多くの言語：コンパイラで事前に機械語へ変換
  - JavaScript：エンジンがコードを解析し、実行時に機械語へ変換

### JavaScript は、ブラウザに組み込まれたエンジンや Node.js で動作する

- 役割: JS コードを解析 → 機械語に変換 → 実行
- 代表例

  - V8（Chrome、Edge）
  - SpiderMonkey（Firefox）
  - JavaScriptCore（Safari）

- ブラウザ以外でも実行可
  - Node.js（V8 ベース）

### 実行環境ごとにできることが異なる

1. ブラウザ

- HTML/CSS やブラウザ操作が可能
- OS やファイル操作は不可（セキュリティ上）

2. Node.js

- OS やファイル操作が可能
- HTML/CSS 操作は不可

### JavaScript の歴史を軽く紹介

- 1995 年 Netscape 社が「HTML と CSS だけのブラウザに動きを加える」目的で開発
- 当時のエンジンは SpiderMonkey（現在の Firefox に継承）
- 1996 年 Microsoft が対抗して似た言語を開発するも、互換性なし → 標準化され、公式名 ECMAScript に
- 2008 年 Google Chrome & V8 エンジン登場 → JavaScript の実行速度が飛躍的に向上
- 2009 年 Node.js 誕生 → JavaScript がブラウザ外でも使えるようになる
- 2015 年 ECMAScript2015（通称 ES6）が出ると、この年から毎年リリースに変更

### Web の基本仕組み

構成要素

- クライアント（ユーザー＋ブラウザ）
- サーバー

通信の流れ

- クライアントがサーバーにリクエスト送信
- サーバーが処理（ユーザー判別・DB 処理・HTML 生成など）
- サーバーがレスポンス（主に HTML）を返却
- ブラウザが HTML を受け取り、追加で CSS/JS をリクエストし、レンダリング（= HTML や CSS、JavaScript といったコードをもとに描画すること）

### サーバーサイドとクライアントサイド

Web はクライアントとサーバーの通信で成り立ち、JS は主にクライアント（ブラウザ）で動作する。

- クライアントサイド JS：ブラウザ上で動く JS
- サーバーサイド JS：Node.js 等を使ってサーバー上で動く JS

別名：フロントエンド（クライアント）、バックエンド（サーバー）

### ブラウザでの JavaScript 実行方法

- 前提: ブラウザは**Google Chrome**を使う
- 開発者ツールの開き方:

  - GUI: Chrome 右上の 三点メニュー → その他のツール → デベロッパーツール を押す
  - ショートカットキー: Ctrl + Shift + I（閉める場合も同じショートカット）

- 開発者ツールを開いた後の実行までの流れ

  1. **コンソールタブ**をクリック
  2. 文字を打ち込む

  ```javascript
  1 + 1 → 2
  10 * 3 → 30
  "hello".toUpperCase() → "HELLO"
  ```

  3. 1 行ずつ打ち込むと、瞬時に結果が下の行に表示される

  ※エンターを押すと、過去の入出力結果を残しながら、次の入力ができるようになる

### 開発環境の構築

- VSCode をインストール
- VSCode の拡張機能として、アイコンが分かりやすくなる**Material Icon Theme**と、コードの可読性を上げる**Prettier**を入れておく
- Setting で検索窓に render whitespace と入力、出てきたものの all にチェックを入れておく（半角スペースに白い中点がついて見やすくなる）
- VSCode のターミナル機能について
  - `+`ボタンを押すことで、複数ターミナル立ち上げ可能
  - 分割ボタンを押すことで、1 つのターミナルを複数に複製可能（かつそれぞれ別物のように独立してコマンド入力できる ← 環境変数などは連携される）
    - 分割された一つ一つのウィンドウを**ペイン**という
  - ゴミ箱ボタンを押すことで、ターミナルを削除可能
  - `Ctrl + K`: 過去のコマンド削除（ターミナルに`clear`と入力してエンターを押すことでも実行可能。`.bash_history`には残る）

#### 補足 Prettier について

Setting で検索窓に以下キーワードを入力してチェックをつけていく

- default formatter: VSCode にもともと入っているフォーマッタと競合して動かなくなるため、デフォルトフォーマッタに Prettier を指定する
- single quote: format する際に、シングルクォートに統一する
- format on save: 上書き保存時に自動整形する機能

#### 補足 VSCode の設定について

- `Settings.json`で細かく設定可能。通常の UI 設定より細かく制御できる

  - `Setting.json`はで開く
  - 例: Prettier をデフォルトフォーマッターに指定、特定の言語（JavaScript / HTML / CSS など）にのみ適用したい

    - 書き方の例:

      ```json
      "[javascript]": {
      "editor.defaultFormatter": "esbenp.prettier-vscode"
      }
      ```

- 設定スコープの違い

  1. User: 全ての VSCode で共通の設定が反映

  - ``

  2. Workspace: プロジェクト（フォルダ）ごとに固有の設定が反映

  - `.vscode/settings.json`: このファイルをこのディレクトリでプロジェクトフォルダ直下に置く
  - チーム開発の際に VSCode の設定を共有できて便利

#### 補足 VSCode のショートカット

- エディタを閉じる: `Ctrl + W`
- ターミナルを開く・閉じる: `Ctrl + backquote`
- 新しいターミナルを開く: `Ctrl + Shift + @`
- やり直す: `Ctrl + Shift + Z`または`Ctrl + Y`
- 行コピー（下に）: `Shift + Alt + ↓`
- 行コピー（上に）: `Shift + Alt + ↑`
- 行を上や下に移動: `Alt + ↑ / ↓`
- 表示ファイル切り替え: `Ctrl + Tab`（右側タブに開かれたファイルへ）、`Ctrl + Shift + Tab`（左側へ）
- インデント操作: 階層を下げる`Ctrl + ]`、階層を上げる`Ctrl + [`
- 同じ単語を複数選択: `Ctrl + D`（選択箇所が 1 個ずつ増える）、`Ctrl + Shift + L`（全て選択）

#### 補足 VSCode の自作ショートカット

- キー割り当ては GUI と JSON の 2 種類で設定でき、when 条件でエディタとターミナルを使い分けるのがコツ
- おすすめの自作ショートカット

  - ターミナルをゴミ箱に捨てる

    - 割り当てキー: Ctrl + Shift + D（※ただし terminalFocus 時のみ有効）
    - コマンド: workbench.action.terminal.kill
    - 理由:
      - 不要になったターミナルを即削除できる
      - when: terminalFocus を条件にするとエディタで Ctrl + Shift + D が使えるまま
    - 設定の仕方（JSON）

      1. `Ctrl + Shift + P` を押してコマンドパレットを開く
      2. 検索窓に「**Preferences: Open Keyboard Shortcuts (JSON)**」と入力する
      3. Enter を押す → `keybindings.json`が開く
      4. 以下テキストをコピペする

      ```json
      [
        {
          // ターミナルを削除（ターミナル選択（フォーカス）時のみ）
          "key": "ctrl+shift+d", // 割り当てるキー
          "command": "workbench.action.terminal.kill", // 実行するコマンド
          "when": "terminalFocus" // 発動条件
        }
      ]
      ```

      5. 上書き保存する

#### 補足 VSCode のターミナル機能について

- ターミナル・シェル・プロセス・セッションの違い
  - ターミナル: ユーザーが文字で操作するための「画面（窓口）」
  - シェル: 入力されたコマンドを解釈して OS に伝える「通訳」
  - プロセス: 実行中のプログラムそのもの（OS が管理する動作単位）
  - セッション: ユーザーとプロセス群とのやりとりをまとめる「枠組み」
- ターミナル（窓口）から入力した文字は → シェル（通訳）が解釈し → プロセス（プログラム）が動いて → それらをセッション（まとまり）が管理する、という流れ
  - 一つのターミナル（画面）を開くと、1 つのシェルセッション（SID）が始まる
  - 1 つのシェルセッションが始まるときに、1 つのシェルプロセスが始まり、付与される
  - `bash`コマンドや`sh`コマンドを実行することで、2 つ目のシェルプロセスが同じセッション内に追加される
  - 他のコマンドを実行することで、シェルプロセスではない**子プロセス**（それぞれに異なる PID が付与される）
- `+`ボタンを押すことで、複数ターミナル立ち上げ可能（ターミナルごとに異なるセッションとなる）
- 分割ボタンを押すことで、新しいセッションを横に並べて表示

  - 分割された一つ一つのウィンドウを**ペイン**という
  - `+`ボタンでも、分割ボタンでも、どちらも**新しいセッションを作る**点では同じ。

    ← 違いは表示方法（`+` = 新しいタブで独立表示、分割 = 同じウィンドウ内に横並び表示）のみ

    つまり、

    - `+`ボタン → 新しいセッションをタブとして追加
    - 分割ボタン → 新しいセッションを同じ枠内に分割して追加

- ゴミ箱ボタンを押すことで、ターミナルを削除可能
- `Ctrl + K`: ターミナルの画面から過去の表示を消去（ターミナルに`clear`と入力してエンターを押すことでも実行可能。`.bash_history`にコマンド履歴は残る）

### JavaScript を HTML に埋め込む（JavaScript は HTML にベタ打ち）

- プロジェクトフォルダを適当に作成しその中で作業する
- まずは`index.html`を作成する
- `index.html`を開き、「html:5」と入力、エンターを押すと自動で以下のようなフォーマットが入力される

  ```html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Document</title>
    </head>
    <body></body>
  </html>
  ```

- JavaScript のコードは、`<script>`タグで埋め込むことができる
- `<script>`タグは、`<head>`タグか`<body>`タグの中であれば、どこにでも埋め込むことができる
- 以下サンプルコードの場合、まず good morning というポップアップが表示されて、それを消すと、次に hello というポップアップが表示される
- 「Ctrl + R」でブラウザを再読みすれば再び最初のポップアップから表示される

  ```html
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Document</title>
      <script>
        alert('good morning');
      </script>
    </head>
    <body>
      <script>
        alert('hello');
      </script>
    </body>
  </html>
  ```

### JavaScript を HTML に埋め込む（JavaScript は別ファイルにする）

- `index.html`と同じ場所に`main.js`を作成する
- `main.js`に以下の内容を書く

  ```javascript
  alert('hello');
  ```

- `index.html`には以下のように`src`属性を追加する形で書く。ベタ書きよりも`src`属性に記載された内容が優先される
- `src`属性でファイルパスを記載した場合、JavaScript をベタ打ちする必要はなくなるが、閉じタグ`</script>`は省略してはいけない

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="main.js">
      alert('good morning');
    </script>
  </head>
  <body>
    <script>
      alert('hello');
    </script>
  </body>
</html>
```

### 基本文法

- 行末にセミコロンを打つこと
- 改行するなら、セミコロンは無くても動く（実行時に**自動セミコロン挿入（ASI）**が発生するため）が、セミコロンを打つことで改行だと認識される
- つまり、こんな書き方もできる（やらないが）

```javascript
let count = 0;
let newCount = 0;
```

※フォーマッタの都合上上書き保存した際に、`;`で改行がされてしまう。改行しなくてもコードは動くよということが言いたかったのに…

#### コメントアウトの書き方

- 2 種類ある

  - 行コメント
    - `//`で始める
    - その行の残りがすべてコメントになる
    - 行頭にも、コードの末尾にも書ける
    - ただし途中に書くと以降がすべてコメントになるので注意
  - ブロックコメント
    - `/* ... */`で囲む
    - 複数行に渡って記述可能

- コメントを付けるべき場面

  - なぜその処理をしているのか、意図が分かりにくいとき
  - 特殊な制約や例外的な書き方をしているとき
  - ファイルや関数の全体的な目的を示すとき

  ← コードの可読性の方が大事。意図や背景を補足する程度に抑える

#### 変数

- `let 変数名 = 値`で変数を宣言できる
- 一度宣言した後は、`変数名 = 値`（`let`不要）で値の更新ができる
- `let 変数名`でも変数を宣言できる。その場合、初期値は`undefined`となる
- 同じ変数名で二度宣言するとエラーになる

```javascript
let count = 0;
```

- 変数の中身の確認は、`console.log(変数名)`でできる → ブラウザの開発者ツール > Console に出力される

#### 定数

- `const 変数名 = 値`で定数を宣言できる
- 一度宣言した後は、値の更新はできない。「Assignment to constant variable」 のエラーが出る
- 初期値が必須。初期値が無いとエラーになる

```javascript
const x; // エラー: Missing initializer
```

- 定数にできるところは、変数を使うのではなく、できるだけ定数にする（可読性向上のため）

#### 変数や定数の命名ルール

- 使用できる文字: `$`（先頭・中間どこでも OK）、`_`（先頭・中間どこでも OK）
- 使用できない文字: `-`、`*`
- 数字は先頭に置けない、途中に入れるのは OK（❌`7TomatoCount`、✅ `Tomato7Count`）
- `const`, `let`, `if`, `for`など JavaScript で予約されている単語は変数名にできない
- 変数名は大文字と小文字を区別する
- 日本語を変数にできるが、英語で書くのを推奨
- **キャメルケース**（例: camelCase、最初は小文字、次の単語から大文字）を推奨。**スネークケース**（例: snake_case、単語をアンダースコアでつなぐ）は非推奨。クラス名では**パスカルケース**（例: PascalCase、単語の頭は全部大文字）を使用（変数・定数には使わない）

#### 変数の有効範囲（スコープ）

- グローバルスコープとローカルスコープの 2 種類ある

  - グローバルスコープ
    - プログラム全体で有効
    - グローバル変数を含む
  - ローカルスコープ

    - 特定の場所だけで有効
    - 関数スコープ

      - 関数の中だけで有効
      - 例:

        ```js
        function testFunction() {
          let x = 10; // 関数スコープの変数
          console.log('関数内:', x);
        }

        testFunction();

        console.log('関数外:', x); // ❌ エラー: x is not defined
        ```

    - ブロックスコープ

      - if や for などの波括弧 {} 内だけで有効
      - 例:

        ```js
        if (true) {
          let y = 20; // ブロックスコープの変数
          console.log('ブロック内:', y);
        }

        console.log('ブロック外:', y); // ❌ エラー: y is not defined
        ```

- 名前が衝突した場合

  - 外側（グローバル）と内側（ローカル）で同じ名前の変数があると、内側が優先される
  - この現象を**シャドーイング（shadowing）**と呼ぶ

#### 算術演算子

| 演算子 | 記号 | 例       | 結果 |
| ------ | ---- | -------- | ---- |
| 足し算 | `+`  | `2 + 5`  | `7`  |
| 引き算 | `-`  | `10 - 7` | `3`  |
| 掛け算 | `*`  | `3 * 4`  | `12` |
| 割り算 | `/`  | `12 / 4` | `3`  |
| 余り   | `%`  | `32 % 5` | `2`  |
| 累乗   | `**` | `2 ** 3` | `8`  |

#### 代入演算子

- `=`を代入演算子という
- 変数には、**値**だけでなく**変数**も代入可能
- 省略記法（複合代入演算子）

```js
result += 10; // result = result + 10
result -= 10; // result = result - 10
result *= 10; // result = result * 10
result /= 10; // result = result / 10
result %= 10; // result = result % 10
result **= 10; // result = result ** 10
```

#### インクリメント演算子・デクリメント演算子

- インクリメント演算子（`++`）
  - 意味: 値を 1 増やす
  - 書き方の種類:
    - 前置型`++x` → 値を増やしてから出力する
    - 後置型`x++` → 値を出力してから増やす

```js
let a = 5;
console.log(a++); // 5 （返すのは元の値）
console.log(a); // 6

a = 5;
console.log(++a); // 6 （返すのは更新後の値）
console.log(a); // 6
```

- デクリメント演算子（`--`）
  - 意味: 値を 1 減らす
  - 書き方の種類:
    - 前置型`--x` → 値を減らしてから出力する
    - 後置型`x--` → 値を出力してから減らす

```js
let a = 5;
console.log(a--); // 5 （返すのは元の値）
console.log(a); // 4

a = 5;
console.log(--a); // 4 （返すのは更新後の値）
console.log(a); // 4
```

- インクリメント演算子やデクリメント演算子は、改行や返り値の違いでバグを生みやすいので、使わない方が良い。使うなら複合代入演算子（`+=`など）

#### 等価演算子

- 厳密等価演算子`===`: 左右の**値**と**型**が同じなら`true`を返す
- 厳密不等価演算子`!==`: 左右の**値**と**型**が一致していないなら`true`を返す
- 等価演算子`==`: 値だけを比較（型は無視）
- 不等価演算子`!=`: 値だけを比較（型は無視）
- 否定（NOT）`!`: `true`と`false`で値を反転させる

→ 「型まで正しく一致しているかどうかを厳しくチェックする」ために、`===` / `!==` を常に使うのがベストプラクティス！
`==`と`!=`は予期せぬ挙動を招くため使用は非推奨

#### 補足 オブジェクト比較における等価演算子のふるまい

1. 基本ルール

- `===` / `==` は **オブジェクトそのものの参照（中身ではなく「場所」）**を比較する
- **見た目が同じでも、新しく作られたオブジェクトは別物**として扱われる

2. 具体例

(1) 新しく作ったオブジェクト同士

```js
const coffee1 = { name: 'カフェラテ' };
const coffee2 = { name: 'カフェラテ' };

console.log(coffee1 === coffee2); // false
```

- 同じ形・同じ内容でも、異なるオブジェクトなので`false`

(2) 代入した場合

```js
const coffee1 = { name: 'カフェラテ' };
const coffee3 = coffee1;

console.log(coffee1 === coffee3); // true
```

- `coffee3`は`coffee1`と同じオブジェクトを参照しているため`true`

(3) プロパティの比較

```js
console.log(coffee1.name === coffee2.name); // true
```

- プロパティは文字列なので、同じ内容なら`true`

3. 配列の場合も同様

- 配列もオブジェクトなので同じ挙動になる

```js
const fruits1 = ['apple', 'banana'];
const fruits2 = ['apple', 'banana'];

console.log(fruits1 === fruits2); // false
```

- 見た目が同じでも別オブジェクト → `false`

4. まとめ

- オブジェクトや配列の比較は「参照」を比べる
- 同じ中身でも別々に作成したら`false`
- 同じものを指している（代入した）場合のみ`true`
- 値を比べたい場合は**プロパティや要素を取り出して比較**する必要がある

#### 比較演算子

- `>`（大なり演算子）
- `>=`（大なりイコール演算子）
- `<`（小なり演算子）
- `<=`（小なりイコール演算子）

- 数値の比較に使うが、文字列でも利用可能。文字列の場合、比較は**辞書順（Unicode 値の大小）**で行われる
- 例 1: `"A" < "B"` → `true`（辞書順で A が先に来るため）
- 例 2: `"A" < "a"` → `true`（Unicode 上、小文字は大文字より後ろ）

#### 論理演算子

- 論理積（AND）`&&`: 両方が truthy のときだけ truthy
- 論理和（OR）`||`: どちらか一方でも truthy なら truthy

← ここでの判定は true/false だけでなく truthy / falsy を使う点が重要

- 論理演算子は、boolean ではなくオペランドそのものを返す（オペランド：論理演算子を挟む値それぞれのこと）

  - AND の場合: 左が falsy なら 左を返す（右は評価しない）、左が truthy なら 右を返す

    ```js
    'HELLO' && 'はい'; // => "はい"   （左が truthy → 右を返す）
    0 && 'ok'; // => 0        （左が falsy  → 左を返す）
    true && false; // => false
    ```

  - OR の場合: 左が truthy なら 左を返す（右は評価しない）、左が falsy なら 右を返す

    ```js
    'HELLO' || 'はい'; // => "HELLO" （左が truthy → 左を返す）
    '' || 'デフォルト'; // => "デフォルト"（左が falsy → 右を返す）
    false || 0; // => 0
    ```

#### 演算子の優先順位

- 優先順位は MDN に一覧がある（高いものから順に評価）
- 例に出てきたものの順序:

  - `>` / `<`（大小比較）
  - `===`（厳密等価）
  - `&&`（AND）
  - `||`（OR）
  - `=`（代入） ← 最も後で評価される

- 評価の流れ（例）式: `OK = (x === 10 || x === 12) && userName`

  - （`>` や `<` → 大小比較を判定）← 無しのためスキップ
  - `===` → 値の等価判定
  - `&&` → 左が truthy なら右を返す
  - `||` → 左が falsy なら右を返す
  - `=` → **最後に代入が実行**

- 丸カッコの推奨

  - 優先順位は覚えるのがややこしい
  - 丸カッコでグループ化すれば意図が明確になる
  - VSCode / Prettier などの整形ツールも自動でカッコを追加してくれる

#### データの型

- JavaScript は**動的型付け**。実行時に型が決まるため、変数に数値を入れた後に文字列を代入しても OK
- 補足: C や Java は静的型付け。コンパイル時に型が決まる
- 補足: 「動的」と「静的」の一般的な意味
  - 動的 (dynamic) = 状況によって変わるもの
  - 静的 (static) = 常に一定で変わらないもの
  - 例:
    - HTML + CSS だけのサイト → 静的サイト
    - Twitter のように見るタイミングで内容が変わるサイト → 動的サイト
- JavaScript にあるデータの型
  - 数値型
    - 整数（integer）
    - 小数（float）
  - 文字列型
  - boolean 型:`true`と`false`のみ。**真偽値**ともいわれる
  - 配列型: **Array**ともいう
  - オブジェクト（Object）型: キー（key）と値（value）のセットで構成される → セット全体を プロパティ と呼ぶ
- データ型を調べる`typeof`演算子: `typeof 値`で値のデータ型を文字列で返す

  - ただし、配列は`"object"`と返ってしまう。配列かどうかの判定には、`Array.isArray(配列かどうか確かめたい変数)`を使用する
  - ただし、`null`は`"object"`と返ってしまう。null かどうかの判定には、厳密等価演算子`=== null`を使用する

  | 入力例                | 結果（返り値）                         |
  | --------------------- | -------------------------------------- |
  | `typeof 3`            | `"number"`                             |
  | `typeof 3.14`         | `"number"`                             |
  | `typeof NaN`          | `"number"`                             |
  | `typeof true`         | `"boolean"`                            |
  | `typeof "Hello"`      | `"string"`                             |
  | `typeof { name: "A"}` | `"object"`                             |
  | `typeof [1, 2, 3]`    | `"object"` ※配列もオブジェクト扱い     |
  | `typeof undefined`    | `"undefined"`                          |
  | `typeof null`         | `"object"` ※歴史的仕様による特殊ケース |

#### `null`と`undefined`の違い

- `null`: 「意図的に何もない」と示したいときに使う

  - 「何もない」ことを明示的に表す値
  - 使いどころ
    - ログインしていないユーザー情報
    - データが存在しないことを「意図的に」示す場合
  - 基本的に 開発者が代入して使う

- `undefined`: JavaScript が自動的に返す「未定義」状態

  - 「値が設定されていない」ことを表す値
  - 使われる場面

    - 変数を宣言したが初期値を与えなかった場合

      ```js
      let userInfo; // → undefined
      ```

    - 存在しないプロパティや配列要素にアクセスした場合

      ```js
      coffee.hello; // → undefined
      arr[10]; // → undefined
      ```

  - JavaScript が 暗黙的に返す
  - `undefined`を明示的に代入しないのが一般的。「空」を表すなら`null`を使う

#### truthy / falsy な値について

- JavaScript は**真偽値が必要な場面で自動的に型変換**を行う
  - **truthy（トゥルーシー）**: `true`として扱われる値
  - **falsy（フォルシー）**: `false`として扱われる値
- falsy 値の一覧（8 種類） ➡ これ以外はすべて truthy
  1. `false`
  2. `0`
  3. `-0`
  4. `0n`（BigInt のゼロ）
  5. `""`（空文字列）
  6. `null`
  7. `undefined`
  8. `NaN`
- 注意
  - `{}`（空オブジェクト） → truthy
  - `[]`（空配列） → truthy
  - `"false"`（文字列としての "false"） → truthy（内容に関係なく非空文字列だから）

#### 文字列の書き方

- シングルクォート「''」、ダブルクォート「""」、バッククォート「``」の 3 種類の囲み方がある
- `+`演算子で複数の文字列を結合できる

  ```js
  let name = 'Yoshi';
  let str = 'Hello ' + name + '!';
  ```

- バッククォート+`${}`で変数や式を文字列に埋め込める

  ```js
  let name = 'Yoshi';
  let str = `Hello ${name}!`; // Hello Yoshi!
  let calc = `2 + 3 = ${2 + 3}`; // 2 + 3 = 5
  ```

- 特殊文字の扱い

  - 別のクォートで囲む（ダブルならシングル、シングルならダブル）
  - エスケープはバックスラッシュでできる

    ```js
    'It\'s OK';
    "He said \"Hi\"";
    ```

- 改行の扱い

  - シングル / ダブルクォート

    - 改行は直接入れられない（エラーになる）
    - 改行したい場合は \n を使う

      ```js
      'Hello\nWorld';
      ```

  - バッククォート

    - 直接改行できる（そのまま文字列に反映される）

      ```js
      `Hello
      World`;
      ```

- シングルクォート、ダブルクォート、バッククォートの 3 種類の囲み方がある
  - シングル or ダブル → 通常の文字列
    - （好みやチーム規約に合わせる、Prettier 設定で統一可能）
  - バッククォート → 変数埋め込みや複数行文字列で便利
    - 機能的には“上位互換”

#### 数字と文字列の組み合わせ

- 足し算 (`+`)は特殊。一見数値の足し算に見えても、**必ず文字列の結合**が行われる（計算は行われない）

  - 文字列 + 文字列: `"10" + "10"  // → "1010"` → 文字列同士の結合になる
  - 文字列 + 数値: `"10" + 10    // → "1010"` → 数値が文字列に変換されてから結合される（暗黙的型変換）

- 足し算以外の演算子（引き算 (`-`) / 掛け算 (`*`) / 割り算 (`/`) / 余り (`%`) / 累乗 (`**`)）は、**必ず文字列でも数値に変換されて**計算される

  ```js
  '10' - 5; // → 5
  '6' * '2'; // → 12
  '20' / 4; // → 5
  '7' % 3; // → 1
  '2' ** '3'; // → 8
  ```

- 数値に変換できない文字列の場合（例: `"Hello" * 10`）、結果は`NaN`（Not a Number、数値ではない、の意）。
  - NaN のデータ型は Number（数値）型

#### データ型の変換

- 文字列を数値にする

  1. `Numder("数字")`:数字の文字列をそのまま数値に変換
  2. `parseInt("数字")`: 小数点以下切り捨てで整数に変換
  3. `parseFloat("数字")`: 小数点以下も含めてそのまま数値に変換
  4. `+"数字"`（単項プラス）: 短く書けるが、可読性が下がるので使わない方が良い

- 数値を文字列にする

  1. `String(数字)`: 数字をそのまま数字の文字列に変換
  2. `(数字).toString()`: 同上。原則`String(数字)`を使うべし

- ただし、型変換できない文字列を数値に変換しようとすると`NaN`になる

  - 例: `Number("Hello") // → NaN`
  - NaN 自体は**Number 型**である

#### 配列

- 要素をひとまとめに羅列したもの。例: `["alice", "bob"]`
- 角括弧`[]`を使用。要素として、文字列・数値・真偽値・配列（入れ子構造も可）・変数を格納できる
- インデックス番号（0 始まり、0-based index）でアクセスできる。例: `names[0] → alice`
- `push()`メソッドで末尾に追加できる

  ```js
  let fruits = ['Apple', 'Banana', 'Grape'];

  fruits[0]; // "Apple"
  fruits[1]; // "Banana"

  fruits.push('Melon');
  console.log(fruits); // ['Apple', 'Banana', 'Grape', 'Melon']
  ```

#### オブジェクト

- キーと値のペアを持つデータの入れ物。Python でいう**辞書**のこと
- 例: `const user = { name: "Alice", age: 20 };`
  - キー: `"name"`, `"age"`
  - 値: `"Alice"`, `20`
- 波括弧`{}`を使用。値として、文字列・数値・真偽値・配列・ほかのオブジェクトを格納できる。
- 最後のプロパティ末尾のカンマは「あり／なし」どちらでも良いが、ありにしておくと Git 管理時に便利（差分が最小化できる）
- アクセス方法
  - ドット記法: `coffee.size; // 350`
  - 値の変更: `coffee.isHot = false;` 上書きできる
  - 新しいプロパティ追加: `coffee.barista = "Reshi";`

```js
const coffee = {
  name: 'Chocolate Mocha',
  size: 350,
  isHot: true,
  toppings: ['Cinnamon', 'Caramel'],
  nutrition: { calories: 430, sugar: 20 },
};
```

#### プロパティ

- オブジェクトの「キーと値」の 1 つ 1 つのこと
- `オブジェクト.キー名`で値にアクセスできる
  - 例: `user.name` → `"Alice"`
  - 例: user["age"] → `20` **もちろんこのような引き出し方も可能**

#### オブジェクト → 配列 に変換するメソッド 3 種

| メソッド              | 返り値                     | 例: `{ q: "alice", limit: 50 }` の場合 |
| --------------------- | -------------------------- | -------------------------------------- |
| `Object.keys(obj)`    | **キーだけ**の配列         | `["q", "limit"]`                       |
| `Object.values(obj)`  | **値だけ**の配列           | `["alice", 50]`                        |
| `Object.entries(obj)` | **\[キー, 値] ペアの配列** | `[["q", "alice"], ["limit", 50]]`      |

#### 関数の書き方

- 関数宣言と呼び出しの例

  - 関数宣言の場合、`}`の後にはセミコロンはつけない。ブロック文自体「1 つのまとまり」であり、値を返すものではない（式ではない）ため、「ここで文が終わった」と明示するセミコロンは不要（しつこくなってしまう）
  - 補足: 関数式の場合、セミコロンは必要（式であるため）

    ```javascript
    // 関数宣言
    function 関数名(引数) {
      処理;
    }

    // 関数式
    const 変数名 = 関数名(引数) {
        処理
    };

    // 呼び出し方
    関数名();
    ```

  - 関数定義側で受け取る変数名のことを**パラメータ（仮引数）**と呼ぶ。関数呼び出し側から渡す実際の具体的な値のことを**引数**と呼ぶ
  - 引数を不足させると、対応するパラメータは`undefined`になる

    ```js
    add(2); // num1 = 2, num2 = undefined
    ```

#### 関数の書き方（返り値編）

- 関数内の処理で`return 値;`と書くと、そこで処理は終了、以降のコードは実行されない
- `return`に何も書かない場合、または`return`自体がない場合は、自動的に`undefined`を返す
- 返り値を使う目的:

  1. 処理結果を利用したい時
  2. 条件分岐などで早期終了したい時

  ```js
  function checkAge(age) {
    if (age < 18) return; // 未成年なら終了（undefined返す）
    console.log('大人です');
  }
  ```

- 戻り値も同じ意味

#### 関数の位置について（巻き上げ）

- 通常は 関数を宣言してから呼び出すが、関数を宣言する前に呼び出すことはできるのか？
  - 技術的には可能。JavaScript はコードを実行する前に関数宣言を巻き上げ（hoisting）する
    - 内部的には、関数がファイルの一番上に持ち上げられているように扱われる
    - そのため、宣言より前でも呼び出せる
  - しかし、しかし可読性の観点から、関数は呼び出しより上に書く方が望ましい
    - 上から下にコードを読むときに理解しやすい

#### アロー関数式

```javascript
const 関数名 = (引数) => {
  返り値;
};
```

#### if 文の書き方

```js
if (条件式1) {
  処理1;
} else if (条件式2) {
  処理2;
} else {
  処理3;
}
```

- `(条件式)`の値が`true`のときに`{}`の中の処理が実行される
- どの条件式にも当てはまらない（`false`となる）場合、`else`につづく`{}`の中の処理が実行される
- `if`のネストは可読性が下がるため、`else if`で書くこと

### JavaScript を使ってブラウザを操作する

#### Web API の利用

- ブラウザが提供する **Web API** を JavaScript のスクリプトに書き込むことで、ブラウザを操作することができる。これらの Web API は JavaScript で書かれているのではなく、**ブラウザ本体のネイティブ言語（多くは C++）**で書かれている
- Web API の例

  1. `alert()`: メッセージを表示する**ダイアログ**を出す。ユーザは「OK」ボタンを押すことで閉じることができる

  - 返り値: `undefined`

  2. `confirm()`: OK / Cancel ボタン付きの**ダイアログ**を出す。ユーザは「OK」または「Cancel」ボタンを押してダイアログを閉じることができる

  - 返り値: OK → `true`、Cancel → `false`

  3. `prompt()`: 入力欄付きの**ダイアログ**を出す

  - 返り値: 入力文字列（Cancel なら`null`）
  - 第 2 引数でデフォルト値を設定可能

  4. `console.log()`: 画面ではなくコンソールに出力する API

  - ECMAScript 仕様には含まれない → WHATWG 等の仕様に記載
  - Node.js でも利用可能（Node.js 側の仕様書で定義されているため）

- 補足 **ダイアログ**とは？

  - 画面の手前に出てくる小窓
  - 背景のページは操作できなくなり（＝モーダル表示）、ユーザーはまずそのダイアログに対応しなければならない
  - ボタンや入力欄がついていることが多い

  ← 主に**デバッグ用途向け**。本番アプリではユーザ体験の観点からほとんど使われない

#### グローバルオブジェクトの利用

- グローバルオブジェクトとは？

  → JavaScript 実行環境ごとに用意される「**最上位のオブジェクト**」。グローバルオブジェクトに登録されたプロパティや関数は、**コード中で直接名前を書くだけで呼び出せる**

  - ブラウザの場合 → `window`オブジェクト
  - Node.js の場合 → `global`オブジェクト

- グローバルオブジェクトの例 1: **navigator オブジェクト**（ブラウザや OS に関する情報を保持するオブジェクト）

  - `navigator.userAgent`: ブラウザ名・バージョン、OS 情報などの文字列
  - `navigator.language`: ブラウザの言語設定（例: `"en"`, `"ja"`）
  - `navigator.clipboard`: クリップボード操作（コピー/ペーストの取得・設定）
  - `navigator.mediaDevices`: 接続されているカメラ・マイクなどの取得 (`getUserMedia()`で利用)
  - `navigator.credentials`: 保存済みのログイン情報（パスワードマネージャ連携）
  - `navigator.geolocation`: 位置情報の取得 (`getCurrentPosition()`で利用、ユーザー許可が必要)

- グローバルオブジェクトの例 2: **screen オブジェクト**（ディスプレイに関する情報を保持するオブジェクト）

  - `screen.width`, `screen.height`: モニター全体の幅・高さ（ブラウザのウィンドウサイズではない）
  - `screen.orientation`: 画面の向き（縦向き / 横向き）

    - `.type`: 現在の向きの種類
    - `.lock()`: 向きを固定するメソッド

#### Location オブジェクトについて

- 現在のページ URL に関する情報を取得・変更できるオブジェクト
- 主に`window.location`または単に`location`でアクセス可能
- URL を構成する各部分を個別に取得できる

  - 例: `window.location.hostname`で URL のドメインの部分だけを取得できる

    ← この、`window.location.`につづく部分をプロパティという

- プロパティの一覧

  - `href`: URL 全体（文字列）。例 `http://example.com/ja/docs`
  - `protocol`: 通信方式（コロン付き）。例 `http:`
  - `hostname`: ホスト名部分（ドメイン）。例 `example.com`
  - `port`: ポート番号。明示されていなければ空文字になる。例 HTTPS → 既定値`443` / HTTP → 既定値`80`
  - `origin`: `protocol + hostname + port`の組み合わせ。例 `http://example.com`
  - `host`: `hostname + port`の組み合わせ。ポート省略時は`hostname`と同じ
  - `pathname`: ドメイン以降のパス部分。例 `/ja/docs`
  - `hash`: `#`以降の部分（ページ内リンクやスクロール位置）。例 `#section1`
  - `search`: `?`以降のクエリ文字列。複数パラメータは`&`で連結。例 `?q=location&lang=ja`

- プロパティのポイント

  - URL を分解して簡単に扱える
  - サーバーにデータを送る「クエリ」やページ内リンク「ハッシュ」も取得可能
  - 実際の Web 開発では、リダイレクトやパラメータ取得に利用される

- **値の代入 = 動的ページ移動**

  - 例: `location.href = "https://google.com"`
  - その URL にリロード（ページ遷移）の意

- 個別プロパティの変更可否

  | プロパティ | 説明                           | 挙動                                                 |
  | ---------- | ------------------------------ | ---------------------------------------------------- |
  | `pathname` | パス名を変更                   | URL のパス部分が変わりリロードされる                 |
  | `search`   | クエリ文字列を変更             | `?q=JavaScript` のように検索パラメータ変更・リロード |
  | `hash`     | ハッシュ（#以降）を変更        | **リロードされない**（同ページ内移動に使える）       |
  | `origin`   | プロトコル＋ホスト＋ポート番号 | **読み取り専用（変更不可）**                         |
  | `host`     | ホスト名＋ポート番号           | 変更可能（リロードされる）                           |

- 例:

  ```js
  location.pathname = 'hello'; // /hello に移動（エラーが出る場合も）
  location.search = '?q=JavaScript'; // クエリ変更＋リロード
  location.hash = 'interface'; // ページ内スクロール（リロードなし）
  ```

- Location メソッドの使い分け

  - ポイント: `assgin`と`replace`の違い

    - `assign`: 履歴に追加 → 戻るボタンで前ページに戻れる
    - `replace`: 履歴を上書き → 戻るボタンで戻れない

  - ブラウザは「戻る／進む」操作用の短期的な履歴を保持
  - `replace()`はその履歴上の現在ページを削除して次に移動
  - JavaScript から履歴の中身を直接参照することはできない（プライバシー保護のため）
  - ただし、「履歴を進む／戻る」といった操作は可能（`history API`で扱う）

  | メソッド                | 挙動                                  | 履歴への影響                                 |
  | ----------------------- | ------------------------------------- | -------------------------------------------- |
  | `location.assign(url)`  | 指定 URL へ移動（＝`href`代入と同じ） | 履歴に**追加される**                         |
  | `location.replace(url)` | 指定 URL へ移動                       | 履歴を**置き換える**（戻るボタンで戻れない） |
  | `location.reload()`     | 現在のページを再読み込み              | そのままリロード                             |

#### History オブジェクトについて

- ブラウザが内部的に保持する「戻る・進むの履歴」を操作するためのオブジェクト
- プライバシー保護のため履歴の URL 自体は参照不可だが、操作は可能
- `window.history`または`history`でアクセスできる

- 基本プロパティ `history.length`: 現在のタブでたどれる履歴の数（現在のページも含む）

  - ページを開いた直後 → 1
  - 3 ページ遷移した後 → 4

- ページ履歴を操作するメソッド

  | メソッド            | 意味         | 挙動                                         | 備考                                 |
  | ------------------- | ------------ | -------------------------------------------- | ------------------------------------ |
  | `history.back()`    | 1 ページ戻る | ブラウザの「戻る」ボタンと同等               | 履歴がない場合は何も起こらない       |
  | `history.forward()` | 1 ページ進む | 「進む」ボタンと同等                         | 履歴がない場合は何も起こらない       |
  | `history.go(n)`     | 指定数分移動 | `n`が正なら進む、負なら戻る、`0`ならリロード | 範囲外の値を指定しても何も起こらない |

- 履歴スタックの制御メソッド

  | メソッド         | 意味                            | 履歴を追加    | 戻るボタンで戻れる？ | 用途                     |
  | ---------------- | ------------------------------- | ------------- | -------------------- | ------------------------ |
  | `pushState()`    | リロードせずに URL だけ変更する | ✅ 追加される | はい                 | 状態を積み重ねたい時     |
  | `replaceState()` | リロードせずに URL だけ変更する | ❌ 置き換える | いいえ               | 現在の状態を更新したい時 |

---

### JavaScript を使って HTTP 通信を行う
