---
title: 02_DBMS
---

# DBMS

## DBの構成と呼び方

- テーブルはExcelのシートのような構造
- **カラム（列）**は「何についての情報か」、**レコード（行）**は「誰／何の情報か」を表す

| 用語         | 意味                                        | 他の呼ばれ方         |
| ---------- | ----------------------------------------- | -------------- |
| **データベース** | データの保管庫そのもの。スキーマ、ユーザー、アクセス権などで構成          | -              |
| **スキーマ**   | テーブルを分類・整理するための「フォルダ」のようなもの。テーブル、ビュー、インデックス、関数などで構成        | -     |
| **テーブル**   | Excelのシートのようなもの      | 表、リレーション、資源      |
| **カラム**    | テーブルの列。属性や項目の種類を表す              | 列、フィールド、項目     |
| **レコード**   | テーブルの行。1件のデータを表す                 | 行、データ行、タプル     |

## インデックス

### インデックスとは？

テーブルとは別に、検索を速くするために検索キーと補助記憶装置（HDD/SSDなど）のアドレス（**ポインタ**という）だけを切り出して検索キーで**ソート**してあげたテーブルのこと

### インデックスのメリット

- ソートしてあるため、検索が速くなる（**二分探索木**を使えるから）

### インデックスのデメリット

- 容量を食う
- テーブルにデータを追加した際に、インデックスの更新に時間がかかる

  → このため、検索の必要のない項目についてはインデックスを付与しない

### インデックスのつけ方

- テーブルの主キーにはデフォルトでインデックスがつく
- 他の項目にもインデックスをつけたい場合は「CREATE INDEX」で付けられる

## トランザクション

### トランザクションとは？

一連の複数処理をまとめたもの

- コミット：一連の処理を全て確定すること
- ロールバック：処理をキャンセルしてトランザクション開始前の状態に戻すこと

例）会員コード101 佐藤花子さんの名前を石田花子さんに変更

```sql
START TRANSACTION; -- トランザクションの開始
UPDATE 会員 SET 氏名 = '石田花子'
WHERE 会員コード = 101;
COMMIT -- コミットしてからトランザクションを終了
```

補足：

- `COMMIT`行が無いと、ローカルでは更新されたように見えるものの、別のユーザーから見ると更新されていない

    - 別のユーザーで`FLUSH TABLE;`（MySQL限定）で最新のテーブル情報を取得しなおしても、更新されていない

- `START TRANSACTION`とその後のクエリは別物なので、`;`で区切ることが必要
- MySQLの場合は、`START TRANSACTION`の代わりに`BEGIN`でも良い
- 取り消す場合は、`COMMIT`ではなく`ROLLBACK`を書くこと

## ACID特性

### ACID特性とは？

トランザクションに求められる性質のこと

- A 原子性（Atomicity）：トランザクションが完了するかまったく実行されないかのどちらかであること（途中まで完了は許されない）
- C 一貫性・整合性（Consistency）：トランザクションの実行前後でデータの**整合性**が保たれなければならない（データベースに設定した条件（外部キー制約など）を満たすこと）
- I 独立性・隔離性（Isolation）：トランザクションは他のトランザクションからの影響を受けてはいけない（分離レベルによって影響を受ける度合いがある）
- D 耐久性・持続性・永続性（Durability）：トランザクションの実行結果は障害が起きても回復できなければならない（バックアップやログを使って復旧する）

## MVCC

### MVCCとは？

Multi-Version Concurrency Control、多版式同時実行制御の略

データベースが複数のトランザクションを同時に処理する際に、整合性と一貫性を保ちながらロックを最小限に抑える仕組み

### 具体的には？

- 編集を開始する際に、**スナップショット**（更新前のデータのコピー）という新しい版を生成しておく
- 編集中に別の人が参照したい場合には、スナップショットが参照される（**読み取るだけなら他の人が編集中でも可能**）
- スナップショットがあるおかげで、読み取るだけならロックはされない
- スナップショットは一定のタイミングでクリーンアップされる

## ロック

### ロックとは？

- Aさんが編集中に、Bさんも編集を始めて、2人で同じ値を編集すると、整合性が取れなくなる → この問題を防ぐために、**ロック**をする
  - Aさんが編集を開始すると、テーブルやレコードがロックされる
  - Bさん（別トランザクション）は、ロックが開くまで待ち続ける
- ロックは、**テーブル単位**（テーブルロック）や**行単位**（行ロック）でかけることができる

### ロックの種類

1. 共有ロック：他のトランザクションは、読み取りだけ許可 ※ただし、自分も読み取りしかできない（編集はできない）
2. 専有ロック：このロックがかかると、他のトランザクションは読み取りすらできない

整理すると、以下のようになる

| 項目        | 共有ロック（S）     | 専有ロック（X）       |
| --------- | ------------ | -------------- |
| 同時にSロック可？ | ✅（複数可能）      | ❌（不可）          |
| 同時にXロック可？ | ❌（不可）        | ❌（不可）          |
| 主な用途      | 読み取り（SELECT） | 書き込み（UPDATEなど） |

### ロックのかけ方

例1）商品テーブルに共有ロックをかける

```sql
LOCK TABLE 商品テーブル READ
```

→ これを実行した後は、`UNLOCK`するまで自分も編集できない（自分で更新しようとしてもエラーになってしまうし、他のトランザクションで更新しようとするとロック解除までグルグルが表示されて待ちとなる。ただしずっと待ちはできないので、タイムアウトエラーとなる）


例2）商品テーブルに専有ロックをかける

```sql
LOCK TABLE 商品テーブル WRITE
```

→ これを実行した後は、`UNLOCK`するまで自分だけ読み取り・編集できる（他のトランザクションで読み取りしとするとロック解除までグルグルが表示されて待ちとなる。ただしずっと待ちはできないので、タイムアウトエラーとなる）


例3）ロックしているテーブル全てを解除する

```sql
UNLOCK TABLES
```

## 直列化可能性

並列実行した結果と、直列実行した結果が同じになること（複数のトランザクションを制御する上で必要な概念）

★ この直列化可能性があれば、ACID特性の中のC（一貫性）が保証されることになる

### 直列化可能性を保証するために必要なプロトコル：**2相ロック**（2相ロッキングプロトコル）

- デフォルトではどこにもロックをかけない。必要になったら、その直前で必要なところにだけロックをかける
- ロックが不要になっても、すぐには解除しない。トランザクションの最後にいっぺんに解除する

## デッドロック

- トランザクション同士で、お互いがアンロックするまで、お互いがロックしたテーブルの解除を待ち続けること
- （かみ砕いて言うと）お互いに相手が使っているものを欲しがって、譲らずにずっと待っている状態
- デッドロックは、すべてのトランザクションが、**すべてのロックに成功するまでアンロックができない**という2相ロックのために発生する

### デッドロックが発生しやすい状況

- 専有ロックをかける
- 1つのトランザクションの中に含まれる処理のステップ数が多い（1つのトランザクションに時間がかかる）
- （そもそも）2相ロックプロトコルに従ってロックする方式の場合、デッドロックが発生する可能性がある

### デッドロックの防ぎ方

- デッドロックが起きないようなスケジューリング・順番決めが肝要

### デッドロックの検出

- **待ちグラフ**というデータ構造で、デッドロックを検出する。永久ループがあればデッドロックになる

## トランザクションの分離レベル（「独立性レベル」「隔離性レベル」「分離性レベル」ともいう）

- 複数のトランザクションが同時に動いているときに、互いにどれだけ影響を受けずに実行されるかを決めるレベル
- トランザクションの**整合性を保ちながら同時実行（並行処理）**するための重要な仕組み

### 分離レベルの4段階

| レベル名              | 内容            | 読み取り不整合の種類      | 保証されること          | 特徴                  |
| -------------------- | --------------- | --------------- | ---------------- | ------------------- |
| **READ UNCOMMITTED**（未コミット読み取り） | 他のトランザクションがコミットしなくても、そのデータは自分のトランザクションでも読み取れる | ❌ **ダーティリード（コミットしていなくても読めてしまう）**が発生  | コミット前の変更も読めてしまう  | 最も緩い、整合性が低い/コミットの意味が無くなる |
| **READ COMMITTED**（コミット読み取り） | ほかのトランザクションがコミットした場合、そのデータは自分のトランザクションでも読み取れる | ✅ ダーティリード防止     | コミット済みのデータしか読めない | MySQLのデフォルト・**ファジーリード（ある値がいきなり変わる。アンリピータブルリードともいう）**が発生 |
| **REPEATABLE READ**（反復読み出し可能） | 参照しただけで共有ロックがかかるが、ほかのトランザクションから「追加・削除」はできる/「更新」はできない | ✅ ダーティ/不可視リード防止 | 同じSELECTが同じ結果を返す | Oracleのデフォルト（InnoDB）・**ファントムリード（同じクエリを繰り返したときに件数が変わる（新たな行が挿入された等））**が発生する可能性がある |
| **SERIALIZABLE**（直列化可能）| 参照しただけで共有ロックがかかり、（専有ロックができないため）他のトランザクションからは「追加・削除」「更新」できなくなる | ✅ 全て防止（最高レベル）| 他トランザクションと完全に直列化 | 最も安全だが、ロックが多く遅いため、ほとんど採用されることはない |

※「追加・削除」をすると、レコード数が変わる
※「更新」をすると、値が変わる（上表では、「追加・削除」は更新には含まれない）
※ MySQLの場合は、READ COMMITEDだとしてもファジーリードは発生しない

### 隔離性水準の設定の実際

1. コネクションを2つ立ち上げる
2. 隔離性水準を設定する（試験範囲外）

  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

3. トランザクション開始

  ```sql
  START TRANSACTION;
  SELECT * FROM 販売管理.会員;
  ```

4. 別のコネクションで以下クエリを実行 → 一方のコネクションで共有ロックがかかっているため、待ち → タイムアウトエラー になる

  ```sql
  UPDATE 会員 SET 氏名 = '札幌 一郎' WHERE 会員コード = 1
  ```

5. いったんSELECTしたコネクションのトランザクションをコミットして終了する

  ```sql
  COMMIT;
  ```

6. 隔離性水準を緩いものに設定しなおす

  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
  ```

7. 別のコネクションで以下クエリを実行 → コミットはまだしていない

  ```sql
  START TRANSACTION;
  UPDATE 会員 SET 氏名 = '札幌 一郎' WHERE 会員コード = 1
  ```

8. コミットはしていないが、別のコネクションで以下クエリを実行すると、中身が更新されていることが確認できる

  ```sql
  SELECT * FROM 販売管理.会員;
  ```

## 障害回復

### バッファ

バッファは**一時的なデータの格納先**のことである。メモリのことを指す
データを格納するバッファと、過去のクエリを格納するバッファ（ログバッファ）の2種類ある

バッファのデータはDBサーバを再起動すると消えてしまう（揮発性）ため、あるタイミングでバッファからハードディスクに書き込まれる
ログバッファのデータもDBサーバを再起動すると消えてしまう（揮発性）ため、ハードディスクの更新前ログと更新後ログに書き出しておく

バッファの内容をハードディスクに書き込むことを**チェックポイント**という
ハードディスクには、いつチェックポイントを行ったかをログファイルに**チェックポイントレコード**として記録しておく

チェックポイントのタイミングは、

- 一定時間経過した
- データベースのバッファに空きが無くなった
- ログファイルが切り替わった（ログファイルは複数個で構成されていることがほとんど。3個ある場合、3個目が満杯になったら、1個目に戻るという感じで、繰り返し使っている）

の3種類ある。チェックポイントは、**コミットの有無とは無関係に行われる**

### チェックポイント

- チェックポイントレコードをログに書き出す
- バッファに残っている更新後のデータをデータベースに書き出す

### ロールフォワード

バックアップ時点に戻したデータベースに対して、トランザクションログを順番に再適用して、クラッシュ直前や特定の時点の状態に戻す（復元）処理のこと

#### ロールフォワードのイメージ図

```css
[バックアップ時点] → ログ1 → ログ2 → ログ3 → [最新状態]

ロールフォワード：バックアップ + ログ1 + ログ2 + ログ3
```

#### ロールバックとの違い

| 用語       | 意味                                |
| -------- | --------------------------------- |
| ロールフォワード | 「先に進める」＝ログを使って更新を再適用していく          |
| ロールバック   | 「後ろに戻す」＝トランザクションなどの変更を取り消して元に戻す処理 |

※ロールフォワードをするには、障害発生時点でコミットを終えている必要がある
※障害発生時点でコミットを終えていないトランザクションについては、ロールバックで元に戻してからやり直す必要がある

### WAL（Write Ahead Logging）

- ログをバッファに書き込んでから、データ（テーブル）を更新しようというルール
- なぜWAL？ → テーブルの更新で破損されても、ログ（更新前ログと更新後ログ）を見れば元に戻すことができるため

## バックアップ

- フルバックアップ：今あるデータを全てバックアップすること
- 差分バックアップ：最初にフルバックアップをとったものとの差だけをバックアップすること。直近のバックアップデータを利用したい場合には、最初のフルバックアップに直近の差分バックアップだけの更新をかければよく、速い
- 増分バックアップ：前回のバックアップとの差だけをバックアップすること。直近のバックアップデータを利用したい場合には、最初のフルバックアップ～直近のバックアップの全てのデータを使う必要があり、遅い

### バックアップの実際

一番よく使われるのは、`mysqldump`コマンド。テキスト形式でSQLとしてバックアップされる

```bash
mysqldump -u root -p データベース名 > /backup/fullbackup.sql
```

[上記コマンドの意味]

- 指定した 1つのデータベース をバックアップ
- 含まれるもの：
  - CREATE DATABASE 文（※デフォルトでは含まれない）
  - USE データベース名
  - 各テーブルの CREATE TABLE（= テーブル定義 = スキーマ）
  - テーブルのデータ（INSERT文で入る）
- オプションによって柔軟に制御可能：
  - `--no-data` → データなし（スキーマのみ）
  - `--no-create-info` → スキーマなし（データのみ）

バックアップのSQLファイルを実行するだけでデータベースを復元できる

※補足：Oracleはデータパンプという。
バイナリのダンプファイルに落として、bash上のコマンドで復元する

## 分散データベース

- データが物理的には複数拠点やサーバに分散して保存されること
- ユーザーやアプリケーションからは1つの統合されたデータベースのように見える
  1. **位置**に対する透過性
    - データがどこに存在しているかを意識せずに使えること
    - 移動の透過性ともいう
  2. **分割**に対する透過性
    - テーブルを列や行で分割して別々の場所に保持しても意識せずに使える
    - 分散の透過性ともいう
  3. **複製**に対する透過性
    - データを重複して保持していても1つのデータにアクセスしているように見える
    - 重複の透過性ともいう
- 分散配置される目的：
  - 性能向上（複数ノードで処理を分担（並列化））
  - 可用性向上、障害耐性（一部ノード障害時もシステムが継続）
  - 地理的分散対応（ユーザの近くの拠点で処理）
- 課題：
  - 一貫性の維持（同期遅延・整合性問題）
  - ネットワーク遅延の影響
  - 管理の複雑化（障害時復旧、スキーマ変更など）

### 分散データベースの構成

- ノード：分散先の各サーバ（ノード）がデータの一部または全体を保持
- ネットワーク：ノード間で通信し、同期や問い合わせ処理を行う
- 統一インターフェース：SQLなど統一的なクエリでアクセス可能

### データ配置の方法

1. データ分割（パーティショニング）

  - データを範囲やキーで分けて異なるノードに配置
  - 例：社員IDが1～10000は東京サーバ、10001～20000は大阪サーバ

2. データ複製（レプリケーション）

  - 同じデータを複数ノードにコピーして保持
  → 障害時の耐久性や読み込み負荷分散に有効

### 分散データベースが守るべき**CAP定理**

- C：一貫性（Consistency）：複数個所でデータの整合性が保たれること
- A：可用性（Availability）：どこかで障害が発生しても全体としては使用できること
- P：分断耐性（Partition tolerance）：通信障害が起きても処理を継続できること

※ただし、CAPすべてを満たすことはできない。

- MySQLやOracleなどのRDB：CAと満たすと、Pが犠牲になる
- DynamoDB：APを満たすようにし、Cを犠牲にする
- MongoDB：CPを満たすようにし、Aを犠牲にする

### 分散データベースにおける2相コミット

分散データベースやトランザクション管理で、複数のノード間で整合性を保ちながらトランザクションを確実にコミットするためのプロトコル

- 調停者：コミットを実施したいノード
- 参加者：コミットしてもいいよと許可を出すノード

← 2相コミットでは、参加者全てから許可がでないと、コミットできない。1つからでも許可が出ない場合、調停者は参加者にロールバックしてと指示を出すことになる

### 分散データベースのテーブル結合

- ネストループ法（入れ子ループ法）：1行ずつ前列取り出して結合させていく。計算量は n × m
- セミジョイン法（準ジョイン法）：結合に必要な列の値だけを送って結合させていく。計算量はネストループ法と変わらないが、通信量が節約できる
- マージジョイン法（ソートマージ法）：各表をあらかじめ結合する列でソートし、結合キーを順番に比較しながらマージする。テーブルごとデータを送るため、通信量が膨大になる
- ハッシュ法：あらかじめ結合する列の値のハッシュ値を算出し、その値で結合。等結合（INNER JOIN）のみできる
